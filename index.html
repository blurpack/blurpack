<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <title>blurpack</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --circle-size: 70vmin;
            --center-img-size: 340px; 
        }

        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--bg-color);
            font-family: "Pretendard", sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        .bg-layer {
            position: fixed; inset: 0; z-index: 1; opacity: 0.9;
            filter: blur(400px); transition: filter 0.8s ease-out;
            pointer-events: none;
        }
        .bg-layer img { width: 100%; height: 100%; object-fit: fill; }

        .viewport-circle {
            position: fixed; width: var(--circle-size); height: var(--circle-size);
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            border-radius: 50%; background: var(--bg-color);
            overflow: hidden; z-index: 10; cursor: grab;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.15), 0 0 50px rgba(0, 0, 0, 0.05);
            opacity: 0; filter: blur(400px); 
            transition: filter 0.8s ease-out, opacity 0.5s ease-out;
        }

        .world-plane { position: absolute; width: 100%; height: 100%; }

        .category-node {
            position: absolute; left: 50%; top: 50%;
            font-size: 3.5rem; font-weight: 900; 
            cursor: pointer; color: var(--text-color);
            white-space: nowrap; text-transform: lowercase; /* 소문자 표시 */
        }

        .center-image-node {
            position: absolute; left: 50%; top: 50%;
            width: var(--center-img-size); height: auto;
            transform: translate(-50%, -50%); pointer-events: none;
        }

        #content-layer {
            position: fixed; top: -100%; left: 0; width: 100%; height: 100%;
            z-index: 100; background: var(--bg-color); overflow-y: auto;
            transition: top 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #content-layer.active { top: 0; }

        /* 갤러리 디자인 */
        .tile-grid { display: grid; grid-template-columns: repeat(1, 1fr); width: 100%; }
        .tile-item { position: relative; width: 100%; overflow: hidden; border-bottom: 1px solid #eee; padding-bottom: 20px;}
        .tile-item img { width: 100%; aspect-ratio: 1/1; object-fit: cover; display: block; }
        .tile-info { padding: 15px; color: black; }
        .tile-info h3 { margin: 0; font-size: 1.2rem; }
        .tile-info p { margin: 5px 0 0; font-size: 0.9rem; opacity: 0.7; }

        @media (min-width: 769px) { .tile-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 768px) {
            :root { --circle-size: 85vmin; --center-img-size: 180px; }
            .category-node { font-size: 2rem; }
        }
        /* 개별 아이템 컨테이너 */
.tile-item {
    position: relative;
    width: 100%;
    cursor: pointer;
    overflow: hidden;
}

.tile-item img {
    width: 100%;
    display: block;
    transition: filter 0.3s ease; /* 블러 애니메이션 속도 */
}

/* 글씨가 들어갈 검은색 반투명 레이어 */
.tile-overlay {
    position: absolute;
    inset: 0; /* 전체 꽉 채우기 */
    background: rgba(0, 0, 0, 0.4); /* 배경 살짝 어둡게 */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    opacity: 0; /* 처음엔 안 보임 */
    transition: opacity 0.3s ease;
    padding: 20px;
    box-sizing: border-box;
}

/* 텍스트 스타일 */
.info-text {
    color: white;
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
}

.info-text h3 { margin: 0; font-size: 1.5rem; }
.info-text p { margin: 5px 0; font-size: 1rem; }
.info-text .tracks { font-size: 0.8rem; opacity: 0.8; margin-top: 10px; }

/* [핵심] 클릭되어 show-info 클래스가 붙었을 때의 모습 */
.tile-item.show-info img {
    filter: blur(15px) brightness(0.7); /* 사진 블러 및 어둡게 */
}

.tile-item.show-info .tile-overlay {
    opacity: 1; /* 글씨 보이기 */
}
    </style>
</head>
<body oncontextmenu="return false;"> 
    
    <div class="bg-layer" id="bgLayer">
        <img src="bpm.webp" alt="background">
    </div>

    <div class="viewport-circle" id="circle">
        <div class="world-plane" id="world">
            <img src="bp_logo_c.webp" class="center-image-node" id="centerImage" alt="center">
        </div>
    </div>

    <div id="content-layer">
        <div class="tile-grid" id="image-gallery"></div>
    </div>

<script>
    async function openPage(folderName) {
        history.pushState({ page: folderName }, folderName, `#${folderName}`);
        gallery.innerHTML = "<p style='padding:20px;'>loading...</p>"; 
        contentLayer.classList.add('active');

        try {
            const response = await fetch(`./${folderName}/data.json`);
            const data = await response.json();
            gallery.innerHTML = ""; 

            data.forEach(item => {
                const tile = document.createElement("div");
                tile.className = "tile-item"; // 기본 상태
                
                // 클릭하면 'show-info' 클래스를 껐다 켰다 함
                tile.onclick = () => tile.classList.toggle('show-info');

                let infoContent = "";
                if (folderName === "musics") {
                    infoContent = `<h3>${item.title}</h3><p>${item.artist}</p><p class="tracks">${item.tracks}</p>`;
                } else {
                    infoContent = `<h3>${item.title}</h3>`;
                }

                tile.innerHTML = `
                    <img src="${folderName}/${item.img}" alt="${item.title}">
                    <div class="tile-overlay">
                        <div class="info-text">${infoContent}</div>
                    </div>
                `;
                gallery.appendChild(tile);
            });
        } catch (error) {
            gallery.innerHTML = `<p style='padding:20px;'>데이터 로드 실패</p>`;
        }
    }
    // 1. 카테고리 설정 (소문자, 새로운 3종)
    const categories = [
        { id: "blurpacks", label: "blurpacks", x: -400, y: -250 },
        { id: "musics",    label: "musics",    x: 450,  y: -100 },
        { id: "movies",    label: "movies",    x: -100, y: 350  }
    ];

    const world = document.getElementById("world");
    const centerImg = document.getElementById("centerImage");
    const contentLayer = document.getElementById("content-layer");
    const bgLayer = document.getElementById("bgLayer");
    const circle = document.getElementById("circle");
    const gallery = document.getElementById("image-gallery");

    let isIntroPlaying = true;

    // 노드 생성
    const nodes = categories.map(cat => {
        const div = document.createElement("div");
        div.className = "category-node";
        div.textContent = cat.label;
        div.onclick = () => { if (!isIntroPlaying && Math.abs(vx) < 1.5) openPage(cat.id); };
        world.appendChild(div);
        return { el: div, x: cat.x, y: cat.y };
    });
    nodes.push({ el: centerImg, x: 0, y: 0 });

    window.onload = () => {
        setTimeout(() => {
            bgLayer.style.filter = "blur(7px)";
            circle.style.filter = "blur(0px)";
            circle.style.opacity = "1";
            setTimeout(() => { isIntroPlaying = false; }, 800);
        }, 100);
    };

    // 2. 페이지 열기 및 데이터 로드 기능
    async function openPage(folderName) {
        history.pushState({ page: folderName }, folderName, `#${folderName}`);
        gallery.innerHTML = "<p style='padding:20px;'>loading...</p>"; 
        contentLayer.classList.add('active');

        try {
            // 해당 폴더의 data.json을 읽어옴
            const response = await fetch(`./${folderName}/data.json`);
            const data = await response.json();
            
            gallery.innerHTML = ""; // 로딩 문구 제거

            data.forEach(item => {
                const tile = document.createElement("div");
                tile.className = "tile-item";
                tile.innerHTML = `
                    <img src="${folderName}/${item.img}" alt="${item.title}">
                    <div class="tile-info">
                        <h3>${item.title}</h3>
                        <p>${item.desc}</p>
                    </div>
                `;
                gallery.appendChild(tile);
            });
        } catch (error) {
            gallery.innerHTML = `<p style='padding:20px; color:red;'>데이터를 불러올 수 없습니다. <br> ${folderName}/data.json 파일이 있는지 확인하세요.</p>`;
        }
    }

    window.onpopstate = () => { if (contentLayer.classList.contains('active')) contentLayer.classList.remove('active'); };

    // 애니메이션 및 인터랙션 로직 (기존 유지)
    let posX = 0, posY = 0, vx = 0, vy = 0, isDragging = false, lastX = 0, lastY = 0;
    const friction = 0.94;

    const start = (x, y) => { if(isIntroPlaying || contentLayer.classList.contains('active')) return; isDragging = true; lastX = x; lastY = y; };
    const move = (x, y) => { if (!isDragging) return; const dx = x - lastX, dy = y - lastY; posX += dx; posY += dy; vx = dx; vy = dy; lastX = x; lastY = y; };
    
    circle.addEventListener('mousedown', e => start(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
    window.addEventListener('mouseup', () => isDragging = false);
    circle.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchend', () => isDragging = false);

    function animate() {
        if (!isDragging && !contentLayer.classList.contains('active')) {
            posX += vx; posY += vy; vx *= friction; vy *= friction;
        }
        world.style.transform = `translate(${posX}px, ${posY}px)`;
        nodes.forEach(node => {
            const currentX = node.x + posX;
            const currentY = node.y + posY;
            const distance = Math.sqrt(currentX * currentX + currentY * currentY);
            const blurVal = Math.min(15, distance / 40); 
            node.el.style.transform = `translate(-50%, -50%) translate(${node.x}px, ${node.y}px)`;
            if (!isIntroPlaying) node.el.style.filter = `blur(${blurVal}px)`;
            node.el.style.opacity = Math.max(0.1, 1 - (distance / 700));
        });
        if (!isIntroPlaying) bgLayer.style.filter = `blur(${7 + (Math.sqrt(vx*vx+vy*vy)*0.1)}px)`;
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>
