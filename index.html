<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>erows – Distant Blur & Updated Grid</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --circle-size: 70vmin;
        }

        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--bg-color);
            font-family: "Pretendard", sans-serif;
        }

        /* 1. 배경 레이어: 속도 기반 블러 */
        .bg-layer {
            position: fixed; inset: 0; z-index: 1; opacity: 0.4;
            transition: filter 0.2s ease-out;
            will-change: filter;
        }
        .bg-text-content {
            padding: 20px; font-size: 8vmin; font-weight: 900;
            line-height: 1.1; color: #000; word-break: break-all;
            user-select: none;
        }

        /* 2. 월드 레이어 (중앙 원) */
        .viewport-circle {
            position: fixed;
            width: var(--circle-size); height: var(--circle-size);
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: var(--bg-color);
            overflow: hidden;
            z-index: 10;
            cursor: grab;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.15), 0 0 50px rgba(0, 0, 0, 0.05);
        }

        .world-plane { 
            position: absolute; 
            width: 100%; height: 100%; 
            will-change: transform; 
        }

        /* 3. 카테고리 노드: 거리 기반 블러 적용 대상 */
        .category-node {
            position: absolute; left: 50%; top: 50%;
            font-size: 4rem; font-weight: 900; 
            cursor: pointer; 
            color: var(--text-color);
            user-select: none;
            will-change: filter, transform;
            white-space: nowrap;
        }

        /* 4. 상세 페이지 레이어 및 수정된 그리드 */
        #content-layer {
            position: fixed; top: -100%; left: 0; width: 100%; height: 100%;
            z-index: 100; background: var(--bg-color); overflow-y: auto;
            transition: top 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #content-layer.active { top: 0; }

        .tile-grid { 
            display: grid; 
            /* 기본(모바일 등 좁은 화면): 가로 1개 배치 */
            grid-template-columns: repeat(1, 1fr); 
            width: 100%; 
        }

        .tile-item { position: relative; width: 100%; aspect-ratio: 1 / 1; overflow: hidden; background: #eee; }
        .tile-item img { width: 100%; height: 100%; object-fit: cover; display: block; }

        /* 데스크톱 등 큰 화면: 가로 2개 배치 */
        @media (min-width: 769px) {
            .tile-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            :root { --circle-size: 85vmin; }
            .category-node { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <div class="bg-layer"><div class="bg-text-content" id="bgText"></div></div>
    <div class="viewport-circle" id="circle"><div class="world-plane" id="world"></div></div>
    <div id="content-layer"><div class="tile-grid" id="image-gallery"></div></div>

<script>
    document.getElementById("bgText").textContent = "FOCUSED DISTANCE BLUR. ".repeat(400);

    const categories = [
        { id: "projects", label: "PROJECTS", x: -400, y: -300 },
        { id: "music",    label: "MUSIC",    x: 550,  y: -150 },
        { id: "movie",    label: "MOVIE",    x: -300, y: 450  },
        { id: "profile",  label: "PROFILE",  x: 0,    y: 0    }
    ];

    const world = document.getElementById("world");
    const contentLayer = document.getElementById("content-layer");
    const bgLayer = document.querySelector('.bg-layer');

    const nodes = categories.map(cat => {
        const div = document.createElement("div");
        div.className = "category-node";
        div.textContent = cat.label;
        div.onclick = () => { if (Math.abs(vx) < 1.5) openPage(cat.label); };
        world.appendChild(div);
        return { el: div, x: cat.x, y: cat.y };
    });

    function openPage(name) {
        history.pushState({ page: name }, name, `#${name}`);
        const grid = document.getElementById("image-gallery");
        grid.innerHTML = ""; 
        for (let i = 0; i < 16; i++) {
            const tile = document.createElement("div");
            tile.className = "tile-item";
            const img = document.createElement("img");
            img.src = `https://picsum.photos/800/800?random=${name}${i}`;
            tile.appendChild(img);
            grid.appendChild(tile);
        }
        contentLayer.classList.add('active');
    }

    window.onpopstate = () => { if (contentLayer.classList.contains('active')) contentLayer.classList.remove('active'); };

    let posX = 0, posY = 0, vx = 0, vy = 0, isDragging = false, lastX = 0, lastY = 0;
    const friction = 0.94;

    const start = (x, y) => { if(contentLayer.classList.contains('active')) return; isDragging = true; lastX = x; lastY = y; };
    const move = (x, y) => { if (!isDragging) return; const dx = x - lastX, dy = y - lastY; posX += dx; posY += dy; vx = dx; vy = dy; lastX = x; lastY = y; };
    
    const circle = document.getElementById("circle");
    circle.addEventListener('mousedown', e => start(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
    window.addEventListener('mouseup', () => isDragging = false);
    circle.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchend', () => isDragging = false);

    function animate() {
        if (!isDragging && !contentLayer.classList.contains('active')) {
            posX += vx; posY += vy; 
            vx *= friction; vy *= friction;
        }

        world.style.transform = `translate(${posX}px, ${posY}px)`;

        // 거리 기반 블러 로직 유지
        nodes.forEach(node => {
            const currentX = node.x + posX;
            const currentY = node.y + posY;
            const distance = Math.sqrt(currentX * currentX + currentY * currentY);

            // 중심에서 멀어질수록 블러 증가 (최대 15px)
            const blurVal = Math.min(15, distance / 40); 
            
            node.el.style.transform = `translate(-50%, -50%) translate(${node.x}px, ${node.y}px)`;
            node.el.style.filter = `blur(${blurVal}px)`;
            
            // 거리에 따른 투명도 변화
            const opacityVal = Math.max(0.2, 1 - (distance / 800));
            node.el.style.opacity = opacityVal;
        });

        const speed = Math.sqrt(vx * vx + vy * vy);
        const bgBlurVal = Math.min(30, 5 + (speed * 0.08));
        if (bgLayer) bgLayer.style.filter = `blur(${bgBlurVal}px)`;

        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>